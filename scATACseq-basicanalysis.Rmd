---
title: "ArchR Tutorial Notebook"
output:
  html_document:
    df_print: paged
---

```{r}
library(ArchR)
set.seed(1)
```

```{r}
addArchRThreads(threads = 4) 
```

```{r}

inputFiles <- c('scATAC' = "D:/Data/scATACseq/Data/2_Processed_data/AJ_v12/fragments.tsv.gz")
inputFiles
```


```{r}
addArchRGenome("mm10")
```

Creating Arrow Files:

```{r}
ArrowFiles <- createArrowFiles(
  inputFiles = inputFiles,
  sampleNames = names(inputFiles),
  filterTSS = 4, #Dont set this too high because you can always increase later
  filterFrags = 1000, 
  addTileMat = TRUE,
  addGeneScoreMat = TRUE
)
```

Have used default values for filterTSS = 4,filterFrags = 1000, as per manual (relevant for human data). Needs to be changed!!

```{r}
ArrowFiles
```
Creation of Arrow files will create a folder in the current working directory called “QualityControl” which will contain 2 plots associated with each of your samples. The first plot shows the log10(unique nuclear fragments) vs TSS enrichment score and indicates the thresholds used with dotted lines. The second shows the fragment size distribution.


## Inferring scATAC-seq Doublets with ArchR

A doublet refers to a single droplet that received a single barcoded bead and more than one nucleus. This causes the reads from more than one cell to appear as a single cell that is effectively the average of the two cells. We remove these computationally!
```{r}
doubScores <- addDoubletScores(
  input = ArrowFiles,
  k = 10, #Refers to how many cells near a "pseudo-doublet" to count.
  knnMethod = "UMAP", #Refers to the embedding to use for nearest neighbor search.
  LSIMethod = 1
)
```
result: UMAP Projection R^2 = 0.96202

```{r}
proj <- ArchRProject(
  ArrowFiles = ArrowFiles, 
  outputDirectory = "/scATAC/",
  copyArrows = TRUE #This is recommended so that you maintain an unaltered copy for later usage.
)
```

```{r}
proj
```


```{r}
getAvailableMatrices(proj)
```

## Manipulating ArchR Project

Access to cellColData

```{r}
head(proj$cellNames)
```

sample names associated with each cell:

```{r}
head(proj$Sample)
```
TSS Enrichment Scores for each cell:

```{r}
quantile(proj$TSSEnrichment)
```
### Plotting QC metrics - log10(Unique Fragments) vs TSS enrichment score

plot the number of unique nuclear fragments (log10) by the TSS enrichment score. This type of plot is key for identifying high quality cells. The cutoffs that we previously specified when creating the Arrow files (via filterTSS and filterFrags) have already removed low quality cells.

```{r}
df <- getCellColData(proj, select = c("log10(nFrags)", "TSSEnrichment"))
head(df)
```

```{r}
p <- ggPoint(
    x = df[,1], 
    y = df[,2], 
    colorDensity = TRUE,
    continuousSet = "sambaNight",
    xlabel = "Log10 Unique Fragments",
    ylabel = "TSS Enrichment",
    xlim = c(log10(500), quantile(df[,1], probs = 0.99)),
    ylim = c(0, quantile(df[,2], probs = 0.99))
) + geom_hline(yintercept = 4, lty = "dashed") + geom_vline(xintercept = 3, lty = "dashed")

p
```

## Plotting Sample Statistics from an ArchRProject

### Make a ridge plot for each sample for the TSS enrichment scores.

```{r}
p1 <- plotGroups(
    ArchRProj = proj, 
    groupBy = "Sample", 
    colorBy = "cellColData", 
    name = "TSSEnrichment",
    plotAs = "ridges"
   )
p1
```

### Make a violin plot for each sample for the TSS enrichment scores.

```{r}
p2 <- plotGroups(
    ArchRProj = proj, 
    groupBy = "Sample", 
    colorBy = "cellColData", 
    name = "TSSEnrichment",
    plotAs = "violin",
    alpha = 0.4,
    addBoxPlot = TRUE
   )
p2
```

### Make a ridge plot for each sample for the log10 (unique nuclear fragments).

```{r}
p3 <- plotGroups(
    ArchRProj = proj, 
    groupBy = "Sample", 
    colorBy = "cellColData", 
    name = "log10(nFrags)",
    plotAs = "ridges"
   )
p3
```
### violin plot for each sample for the log10(unique nuclear fragments).

```{r}
p4 <- plotGroups(
    ArchRProj = proj, 
    groupBy = "Sample", 
    colorBy = "cellColData", 
    name = "log10(nFrags)",
    plotAs = "violin",
    alpha = 0.4,
    addBoxPlot = TRUE
   )
p4
```

## Plotting Sample Fragment Size Distribution and TSS Enrichment Profiles.

### Fragment size distributions

```{r}
p5 <- plotFragmentSizes(ArchRProj = proj)
p5
```

### TSS enrichment profiles

```{r}
p6 <- plotTSSEnrichment(ArchRProj = proj)
p6
```

Saving both these plots
```{r}
plotPDF(p5,p6, name = "QC-Sample-FragSizes-TSSProfile.pdf", ArchRProj = proj, 
        addDOC = FALSE, width = 5, height = 5)
```
```{r}
saveArchRProject(ArchRProj = proj, outputDirectory = "/scATAC/savedproject/SavedProj", load = FALSE)
```
## Filtering Doublets from an ArchRProject:

The higher the filterRatio, the greater the number of cells potentially removed as doublets.

```{r}
proj1 <- filterDoublets(ArchRProj = proj)
```
Filtering 345 cells from ArchRProject!
	scATAC : 345 of 5876 (5.9%)
	
	
## Dimensionality Reduction and Clustering

```{r}
proj <- addIterativeLSI(ArchRProj = proj, useMatrix = "TileMatrix", name = "IterativeLSI")
```
```{r}
proj
```

```{r}
proj <- addClusters(input = proj, reducedDims = "IterativeLSI")
```

## Visualizing in a 2D UMAP Embedding

```{r}
proj <- addUMAP(ArchRProj = proj, reducedDims = "IterativeLSI")
```



```{r}
p1 <- plotEmbedding(ArchRProj = proj, colorBy = "cellColData", name = "Sample", embedding = "UMAP")
```

```{r}
p2 <- plotEmbedding(ArchRProj = proj, colorBy = "cellColData", name = "Clusters", embedding = "UMAP")
```

```{r}
ggAlignPlots(p1, p2, type = "h")
```
## Assigning Clusters with Gene Scores
```{r}
proj <- addImputeWeights(proj)
```

Now we can overlay our marker gene scores on our 2D UMAP embedding.
```{r}
markerGenes  <- c(
    "CD34",  #Early Progenitor
    "GATA1", #Erythroid
    "PAX5", "MS4A1", "MME", #B-Cell Trajectory
    "CD14", "MPO", #Monocytes
    "CD3D", "CD8A"#TCells
  )
p <- plotEmbedding(
    ArchRProj = proj, 
    colorBy = "GeneScoreMatrix", 
    name = markerGenes, 
    embedding = "UMAP",
    imputeWeights = getImputeWeights(proj)
)
```

To plot a specific gene we can subset this plot list using the gene name.

```{r}
p$CD14
```

To plot all genes we can use cowplot to arrange the 9 different plots together. Each of these marker genes lights up the corresponding cell clusters

```{r}
#Rearrange for grid plotting
p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
do.call(cowplot::plot_grid, c(list(ncol = 3),p2))
```
To save an editable vectorized version of this plot, we use the plotPDF() function.

```{r}
plotPDF(plotList = p, 
    name = "Plot-UMAP-Marker-Genes-W-Imputation.pdf", 
    ArchRProj = proj, 
    addDOC = FALSE, width = 5, height = 5)
```