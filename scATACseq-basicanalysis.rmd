---
title: "sc-ATACSeq Analysis"
output:
  html_document: 
    toc: yes
    toc_depth: 5
    fig_caption: yes
    number_sections: yes
    keep_md: yes
    fig_width: 9
    fig_height: 9
    df_print: default
---
# Initialization

```{r}
suppressPackageStartupMessages(library("ArchR"))
suppressPackageStartupMessages(library("tidyverse"))
suppressPackageStartupMessages(library("here"))
suppressPackageStartupMessages(library("scran"))
set.seed(1234)
```

```{r}
# addArchRThreads(threads = 6) 
here::i_am("scATACseq-basicanalysis.rmd")
```
```{r Data Input}
day5 <- "D:/ATACSeq/Data/Sample1/2_Processed_data_S1/AJ_v12/fragments.tsv.gz"

day10 <- "D:/ATACSeq/Data/Sample2/220928_Juergens_Hornef_microbiology_scATACseq/compressed_tars/_2_Processed_data_S2/2_Processed_data/AJ_V12_d10_L129_UI/fragments.tsv.gz"
```
```{r}
inputFiles <- c('scATAC' = c(day5, day10))
inputFiles
```
```{r}
addArchRGenome("mm10")
```

## Creating Arrow Files:

Each Arrow file stores all of the data associated with an individual sample (i.e. metadata, accessible fragments, and data matrices).

```{r}
ArrowFiles <- createArrowFiles(
  inputFiles = inputFiles,
  sampleNames = names(inputFiles),
  minTSS = 4, #Dont set this too high because you can always increase later
  minFrags = 1000, 
  addTileMat = TRUE,
  addGeneScoreMat = TRUE,
  subThreading = TRUE,
  verbose = TRUE,
  cleanTmp = TRUE,
  #force = TRUE,
  logFile = createLogFile("createArrows_Nov")
)
```

Creation of Arrow files will create a folder in the current working directory called “QualityControl” which will contain 2 plots associated with each of your samples. The first plot shows the log10(unique nuclear fragments) vs TSS enrichment score and indicates the thresholds used with dotted lines. The second shows the fragment size distribution.


## Inferring scATAC-seq Doublets with ArchR

A doublet refers to a single droplet that received a single barcoded bead and more than one nucleus. This causes the reads from more than one cell to appear as a single cell that is effectively the average of the two cells. These are removed computationally!
```{r}
doubScores <- addDoubletScores(input = ArrowFiles,
                                k = 30, #Refers to how many cells near a "pseudo-doublet" to count.
                                knnMethod = "LSI", #Refers to the embedding to use for nearest neighbor search.
                                LSIMethod = 1,
                                force = TRUE
)

```
## Creating ArchR Project
```{r}
ATACSeq_project <- ArchRProject(
  ArrowFiles = ArrowFiles, 
  outputDirectory = "D:/ATACSeq/bothsamples/",
  copyArrows = TRUE #This is recommended so that you maintain an unaltered copy for later usage.
)

getAvailableMatrices(ATACSeq_project)
```
We filter putative doublets based on the previously determined doublet scores using the filterDoublets() function. This doesn’t physically remove data from the Arrow files but rather tells the ArchRProject to ignore these cells for downstream analysis. The higher the filterRatio, the greater the number of cells potentially removed as doublets.

```{r}
ATACSeq_project <- filterDoublets(ArchRProj = ATACSeq_project)
```
### Doublet score
```{r}
Doublet_score_df <- as.data.frame(ATACSeq_project$DoubletScore)
quantile(ATACSeq_project$DoubletScore)
```
### TSS Enrichment Scores for each cell:
```{r}
quantile(ATACSeq_project$TSSEnrichment)
```
### Plotting QC metrics - log10(Unique Fragments) vs TSS enrichment score

plot the number of unique nuclear fragments (log10) by the TSS enrichment score. This type of plot is key for identifying high quality cells. The cutoffs that we previously specified when creating the Arrow files (via filterTSS and filterFrags) have already removed low quality cells.

```{r}
df <- getCellColData(ATACSeq_project, select = c("log10(nFrags)", "TSSEnrichment"))
head(df)
```

```{r}
(ggPoint(
    x = df[,1], 
    y = df[,2], 
    colorDensity = TRUE,
    continuousSet = "sambaNight",
    xlabel = "Log10 Unique Fragments",
    ylabel = "TSS Enrichment",
    xlim = c(log10(500), quantile(df[,1], probs = 0.99)),
    ylim = c(0, quantile(df[,2], probs = 0.99))
) + geom_hline(yintercept = 4, lty = "dashed") + geom_vline(xintercept = 3, lty = "dashed"))

```

## Plotting Sample Statistics from an ArchRProject
### Plots (per sample) for TSS enrichment scores.
#### Ridge plot  - TSS enrichment scores.
```{r}
(Group_plot_TSS_ridge = plotGroups(ArchRProj = ATACSeq_project, 
                              groupBy = "Sample", 
                              colorBy = "cellColData", 
                              name = "TSSEnrichment",
                              plotAs = "ridges"
   ))
```
### Violin plot - TSS enrichment scores.
```{r}
(Group_plot_TSS_violin = plotGroups(
    ArchRProj = ATACSeq_project, 
    groupBy = "Sample", 
    colorBy = "cellColData", 
    name = "TSSEnrichment",
    plotAs = "violin",
    alpha = 0.4,
    addBoxPlot = TRUE
   ))
```
### Plots (per sample) for log10 (unique nuclear fragments)
#### Ridge plot  - log10 (unique nuclear fragments)
```{r}
(Group_plot_nFrags_ridge = plotGroups(ArchRProj = ATACSeq_project, 
                                  groupBy = "Sample", 
                                  colorBy = "cellColData", 
                                  name = "log10(nFrags)",
                                  plotAs = "ridges"
))
```
### violin plot for each sample for the log10(unique nuclear fragments).

```{r}
(Group_plot_nFrags_violin = plotGroups(ArchRProj = ATACSeq_project, 
                                      groupBy = "Sample", 
                                      colorBy = "cellColData", 
                                      name = "log10(nFrags)",
                                      plotAs = "violin",
                                      alpha = 0.4,
                                      addBoxPlot = TRUE
))
```

## Plotting Sample Fragment Size Distribution and TSS Enrichment Profiles.
```{r}
(FragSizePlot = plotFragmentSizes(ArchRProj = ATACSeq_project))
(TSSEnrichmentPlot = plotTSSEnrichment(ArchRProj = ATACSeq_project))
```
Saving both these plots and ArchR Project
```{r}
plotPDF(FragSizePlot, TSSEnrichmentPlot,name = "QC-Sample-FragSizes-TSSProfile.pdf",
        ArchRProj = ATACSeq_project, addDOC = FALSE, width = 8, height = 8)

saveArchRProject(ArchRProj = ATACSeq_project, outputDirectory = "D:/ATACSeq/", load = FALSE)

```


## Dimensionality Reduction and Clustering

The reducedDims object called “IterativeLSI”. 
Have used default parameters for iterations, varFeatures, and resolution parameters.
-have used resolution = 0.2.

```{r}
ATACSeq_project <- addIterativeLSI(
    ArchRProj = ATACSeq_project,
    useMatrix = "TileMatrix", 
    name = "IterativeLSI", 
    iterations = 2, 
    clusterParams = list( #See Seurat::FindClusters
        resolution = 0.2, 
        sampleCells = 10000, 
        n.start = 10
    ), 
    varFeatures = 25000, 
    dimsToUse = 1:30
)
```

have not used Harmony for additional batch effect removal!

# Clustering

```{r}
ATACSeq_project <- addClusters(
    input = ATACSeq_project,
    reducedDims = "IterativeLSI",
    method = "Seurat",
    name = "Clusters",
    resolution = 0.8
)
```


## Clusters:

### number of cells present in each cluster:
```{r}
table(ATACSeq_project$Clusters)
```

### Cluster Confusion Matrix

enables to understand which samples reside in which clusters, we can create a cluster confusion matrix across each sample.


```{r}
confusion_Matrix <- confusionMatrix(paste0(ATACSeq_project$Clusters),
                      paste0(ATACSeq_project$Sample)
                      )
confusion_Matrix
```
Lets plot this confusion matrix: (but cannot do at the moment as there is only one sample, need atleast 2)

```{r}
library(pheatmap)
confusion_Matrix <- confusion_Matrix / Matrix::rowSums(confusion_Matrix)
(pheatmap::pheatmap(
   mat = as.matrix(confusion_Matrix),
   color = paletteContinuous("whiteBlue"),
   border_color = "black"))
# p
```
### Clustering using scran
```{r}
suppressPackageStartupMessages(library("scran"))
ATACSeq_project <- addClusters(
    input = ATACSeq_project,
    reducedDims = "IterativeLSI",
    method = "scran",
    name = "ScranClusters",
    k = 15
)
```



# UMAPs

```{r}
ATACSeq_project <- addUMAP(
    ArchRProj = ATACSeq_project, 
    reducedDims = "IterativeLSI", 
    name = "UMAP", 
    nNeighbors = 30, 
    minDist = 0.5, 
    metric = "cosine"
)
```

Lets plot the UMAP results

```{r}
(plotEmbedding(ArchRProj = ATACSeq_project,
                    colorBy = "cellColData", 
                    name = "Sample", 
                    embedding = "UMAP"))
```

```{r}
(plotEmbedding(ArchRProj = ATACSeq_project, 
              colorBy = "cellColData",
              name = "Clusters", 
              embedding = "UMAP"))
```

```{r}
ggAlignPlots(p1, p2, type = "h")
```


```{r}
(plotPDF(p1,p2, 
         name = "Plot-UMAP-Sample-Clusters.pdf",
         ArchRProj = ATACSeq_project, 
         addDOC = TRUE, 
         width = 9, 
         height = 9))
```

## t-Stocastic Neighbor Embedding (t-SNE)

```{r}
proj2 <- addTSNE(
    ArchRProj = proj2, 
    reducedDims = "IterativeLSI", 
    name = "TSNE", 
    perplexity = 30
)
```
## Plotting tSNE

```{r}
p1 <- plotEmbedding(ArchRProj = proj2, colorBy = "cellColData", name = "Sample", embedding = "TSNE")
```
```{r}
p2 <- plotEmbedding(ArchRProj = proj2, colorBy = "cellColData", name = "Clusters", embedding = "TSNE")
```
```{r fig.height=10, fig.width=10}
ggAlignPlots(p1, p2, type = "h")
```

```{r}
plotPDF(p1,p2, name = "Plot-TSNE-Sample-Clusters.pdf", ArchRProj = proj2, 
        addDOC = FALSE, width = 5, height = 5)
```


# Gene Scores and Marker Genes with ArchR

## Identifying Marker Genes

```{r}
markersGS <- getMarkerFeatures(
    ArchRProj = proj2, 
    useMatrix = "GeneScoreMatrix", 
    groupBy = "Clusters",
    bias = c("TSSEnrichment", "log10(nFrags)"),
    testMethod = "wilcoxon"
)
```

## Markers List

```{r}
markerList <- getMarkers(markersGS, cutOff = "FDR <= 0.01 & Log2FC >= 1.0")
```

```{r}
head(markerList$C1, 15)
```

```{r}
head(markerList$C2, 15)
```

```{r}
head(markerList$C3, 15)
```

```{r}
head(markerList$C4, 15)
```


```{r}
head(markerList$C5, 15)
```

```{r}
head(markerList$C6, 15)
```

```{r}
head(markerList$C7, 15)
```

##  visualize all of the marker features simultaneously


```{r}
markerGenes  <- c("Plag2g2a", "Defa-rs1", "Mmp7", 
                  "Lyz1", "Spdef", "Tcf7l2", "Ephb3", "Sis", "Ada", "Lct" )
heatmapGS <- markerHeatmap(
  seMarker = markersGS, 
  cutOff = "FDR <= 0.01 & Log2FC >= 1.0", 
  labelMarkers = markerGenes,
  transpose = TRUE
)
```


```{r}
ComplexHeatmap::draw(heatmapGS, heatmap_legend_side = "bot", annotation_legend_side = "bot")
```
